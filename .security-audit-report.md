# üîí Auditor√≠a de Seguridad - Sistema de Wallets y Transacciones

**Fecha:** 2025-11-24  
**Auditor:** Sistema de Seguridad Automatizado  
**Severidad General:** üî¥ **CR√çTICA**

---

## üìã Resumen Ejecutivo

Se han identificado **M√öLTIPLES VULNERABILIDADES CR√çTICAS** que permiten a cualquier usuario autenticado:
- ‚úÖ Acceder a cuentas de otros usuarios
- ‚úÖ Modificar cuentas que no le pertenecen
- ‚úÖ Crear transacciones en cuentas ajenas
- ‚úÖ Ver historial de transacciones de otros usuarios

**Riesgo:** Un atacante puede manipular balances, robar informaci√≥n financiera y comprometer la integridad del sistema.

---

## üö® Vulnerabilidades Identificadas

### 1. **CR√çTICO: Creaci√≥n de Cuentas Sin Validaci√≥n de Usuario**

**Archivo:** `accounts.controller.ts` (L√≠nea 21-24)  
**Severidad:** üî¥ CR√çTICA

```typescript
@Post('create')
async createAccount(@Body() createAccountDto: CreateAccountDto) {
    return this.createAccountUseCase.execute(createAccountDto)
}
```

**Problema:**
- El endpoint acepta `user_id` desde el body del request
- Un usuario autenticado puede crear cuentas para CUALQUIER `user_id`
- No se valida que el `user_id` del body coincida con el usuario autenticado

**Escenario de Ataque:**
```bash
# Usuario A (autenticado) crea una cuenta para Usuario B
POST /accounts/create
Authorization: Bearer <token_usuario_A>
{
  "user_id": "usuario_B_id",  // ‚Üê Puede poner cualquier ID
  "name": "Cuenta Hackeada",
  "currency": "USD"
}
```

---

### 2. **CR√çTICO: Actualizaci√≥n de Cuentas Sin Verificaci√≥n de Propiedad**

**Archivo:** `accounts.controller.ts` (L√≠nea 26-29)  
**Severidad:** üî¥ CR√çTICA

```typescript
@Put('update/:account_id')
async updateAccount(@Param('account_id') accountId: string, @Body() updateAccountDto: UpdateAccountDto) {
    return this.updateAccountUseCase.execute(accountId, updateAccountDto)
}
```

**Problema:**
- Cualquier usuario autenticado puede actualizar CUALQUIER cuenta
- No se verifica que la cuenta pertenezca al usuario autenticado
- El servicio `UpdateAccountService` solo verifica que la cuenta exista, no la propiedad

**Escenario de Ataque:**
```bash
# Usuario A modifica la cuenta de Usuario B
PUT /accounts/update/cuenta_de_usuario_B
Authorization: Bearer <token_usuario_A>
{
  "name": "Cuenta Comprometida",
  "currency": "BTC"
}
```

---

### 3. **CR√çTICO: Creaci√≥n de Transacciones Sin Validaci√≥n de Propiedad**

**Archivo:** `transaction.controller.ts` (L√≠nea 17-20)  
**Severidad:** üî¥ CR√çTICA

```typescript
@Post('save')
async save(@Body() tx: TransactionDto) {
    return this.saveTransactionUseCase.execute(tx)
}
```

**Problema:**
- Acepta `account_id` desde el body sin validaci√≥n
- Un usuario puede crear transacciones en cuentas que no le pertenecen
- Puede modificar balances de cuentas ajenas

**Escenario de Ataque:**
```bash
# Usuario A crea una transacci√≥n de retiro en la cuenta de Usuario B
POST /transactions/save
Authorization: Bearer <token_usuario_A>
{
  "account_id": "cuenta_de_usuario_B",
  "amount": 10000,
  "type": "expense",  // ‚Üê Vac√≠a la cuenta de otro usuario
  "name": "Robo"
}
```

---

### 4. **ALTO: Exposici√≥n de Historial de Transacciones**

**Archivo:** `transaction.controller.ts` (L√≠nea 22-32)  
**Severidad:** üü† ALTA

```typescript
@Get('history')
async history(
    @Query() query: { skip: string, take: string, account_id: string, user_id: string }
) {
    // ...
    return this.getHistoryTransactionUseCase.execute(query.account_id, ...)
}
```

**Problema:**
- Acepta `account_id` y `user_id` desde query params
- Un usuario puede consultar el historial de transacciones de CUALQUIER cuenta
- No valida que el usuario autenticado sea el due√±o

**Escenario de Ataque:**
```bash
# Usuario A consulta transacciones de Usuario B
GET /transactions/history?account_id=cuenta_de_B&user_id=usuario_B
Authorization: Bearer <token_usuario_A>
```

---

### 5. **MEDIO: Falta de Validaci√≥n en Obtenci√≥n de Cuentas**

**Archivo:** `accounts.controller.ts` (L√≠nea 31-35)  
**Severidad:** üü° MEDIA

```typescript
@Get('get/all/:user_id')
async getAllAccounts(@Param('user_id') userId: string) {
    return await this.getAllAccountsUseCase.execute(userId)
}
```

**Problema:**
- Acepta `user_id` como par√°metro de ruta
- Un usuario puede listar las cuentas de CUALQUIER usuario
- No valida que el `user_id` coincida con el usuario autenticado

**Escenario de Ataque:**
```bash
# Usuario A lista todas las cuentas de Usuario B
GET /accounts/get/all/usuario_B_id
Authorization: Bearer <token_usuario_A>
```

---

## üîç An√°lisis de Autenticaci√≥n

### Estado Actual
- ‚úÖ **JwtAuthGuard** est√° implementado y activo en todos los endpoints
- ‚úÖ Los usuarios deben estar autenticados para acceder
- ‚ùå **NO hay autorizaci√≥n** - solo verifica que el usuario est√© autenticado, no que tenga permisos

### JWT Payload
```typescript
// jwt.strategy.ts - L√≠nea 16-17
async validate(payload: any) {
    return { userId: payload.sub, email: payload.email };
}
```

El payload del JWT contiene `userId`, pero **NUNCA se utiliza** para validar la propiedad de recursos.

---

## ‚úÖ Soluciones Recomendadas

### Soluci√≥n 1: Usar el Usuario Autenticado del Request

Modificar todos los endpoints para usar el `userId` del token JWT en lugar de aceptarlo como par√°metro:

```typescript
// Ejemplo: accounts.controller.ts
@Post('create')
async createAccount(
    @Request() req,  // ‚Üê Obtener usuario del token
    @Body() createAccountDto: Omit<CreateAccountDto, 'user_id'>
) {
    const userId = req.user.userId;  // ‚Üê Del JWT
    return this.createAccountUseCase.execute({
        ...createAccountDto,
        user_id: userId  // ‚Üê Forzar el userId del token
    })
}
```

### Soluci√≥n 2: Implementar Guards de Autorizaci√≥n

Crear guards personalizados para verificar propiedad:

```typescript
// account-owner.guard.ts
@Injectable()
export class AccountOwnerGuard implements CanActivate {
    constructor(private accountRepository: AccountRepository) {}
    
    async canActivate(context: ExecutionContext): Promise<boolean> {
        const request = context.switchToHttp().getRequest();
        const userId = request.user.userId;
        const accountId = request.params.account_id;
        
        const account = await this.accountRepository.findById(accountId);
        
        if (!account || account.user_id !== userId) {
            throw new ForbiddenException('No tienes permiso para acceder a esta cuenta');
        }
        
        return true;
    }
}
```

### Soluci√≥n 3: Validaci√≥n en la Capa de Servicio

Agregar validaciones de propiedad en los servicios:

```typescript
// update-account.service.ts
async execute(userId: string, accountId: string, updateAccountDto: UpdateAccount) {
    const account = await this.accountRepository.findById(accountId);
    
    if (!account) {
        throw new Error('Account not found');
    }
    
    // ‚Üê VALIDACI√ìN DE PROPIEDAD
    if (account.user_id !== userId) {
        throw new ForbiddenException('No tienes permiso para modificar esta cuenta');
    }
    
    return this.accountRepository.update(accountId, updateAccountDto);
}
```

---

## üìä Priorizaci√≥n de Correcciones

| Prioridad | Vulnerabilidad | Impacto | Esfuerzo |
|-----------|---------------|---------|----------|
| 1Ô∏è‚É£ | Creaci√≥n de transacciones sin validaci√≥n | Manipulaci√≥n de balances | Medio |
| 2Ô∏è‚É£ | Actualizaci√≥n de cuentas sin validaci√≥n | Modificaci√≥n de datos | Bajo |
| 3Ô∏è‚É£ | Creaci√≥n de cuentas sin validaci√≥n | Suplantaci√≥n | Bajo |
| 4Ô∏è‚É£ | Acceso a historial de transacciones | Fuga de informaci√≥n | Bajo |
| 5Ô∏è‚É£ | Listado de cuentas de otros usuarios | Fuga de informaci√≥n | Bajo |

---

## üéØ Plan de Acci√≥n Inmediato

1. **DETENER PRODUCCI√ìN** si el sistema est√° en producci√≥n
2. Implementar validaci√≥n de `userId` en TODOS los endpoints
3. Crear guards de autorizaci√≥n para recursos
4. Agregar tests de seguridad
5. Realizar auditor√≠a de logs para detectar posibles ataques previos
6. Implementar rate limiting para prevenir abuso

---

## üìù Checklist de Seguridad

- [ ] Validar que `user_id` del token coincida con el recurso solicitado
- [ ] Implementar guards de autorizaci√≥n
- [ ] Nunca confiar en datos del cliente (body, params, query)
- [ ] Validar propiedad de recursos en la capa de servicio
- [ ] Agregar logging de acciones sensibles
- [ ] Implementar tests de seguridad
- [ ] Documentar pol√≠ticas de acceso

---

## üîó Referencias

- [OWASP Top 10 - Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)
- [NestJS Guards Documentation](https://docs.nestjs.com/guards)
- [NestJS Security Best Practices](https://docs.nestjs.com/security/authorization)

---

**Conclusi√≥n:** El sistema actual tiene vulnerabilidades cr√≠ticas de control de acceso que deben ser corregidas INMEDIATAMENTE antes de cualquier despliegue en producci√≥n.
